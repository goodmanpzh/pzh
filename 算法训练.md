## 算法训练

😀**把坑都踩过一遍之后，就无敌了**


### 一、数组的基本方法

1. 使用双指针
2. 暴力解法（for循环）
3. 滑动窗口（另一种双指针）（求数组中的符合求和的最小长度，窗口中的sum值不断变化，会增加和减少，不要每次都重新计算）
4. 快速排序（手敲）
5. 螺旋矩阵：找出要循环的圈数，找出循环中的不变量，左闭右开。（使用vector构建二维数组时，需要将 '>>'写为'>  >'，因为有运算符重载）

---

> 1. vector使用：[详解](https://blog.csdn.net/weixin_41743247/article/details/90635931?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170467483016800186572380%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170467483016800186572380&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-90635931-null-null.142^v99^pc_search_result_base1&utm_term=vector&spm=1018.2226.3001.4187)
>
> 2. C++最大最小值赋值：
>
>    INT_MIN:-2147483648
>    INT_MAX:2147483647
>    LONG_MIN:-2147483648
>    LONG_MAX:2147483647
>    LLONG_MIN:-9223372036854775808
>    LLONG_MAX:9223372036854775807

### 二、链表（设置虚拟头结点）

1. 移除链表元素
2. 链表方法实现
   - 先定义结构体，在定义链表类，在类中实现具体的方法
3. 实现链表的反转
   - 对于空指针的链表要先处理！
   - 隐蔽的错误，NULL没有next，单独处理空节点，或者不能使用空节点
4. 两两交换链表中的元素
   - 设置头结点，判断两个不等于空的顺序不能反，交换时可以看做直接将中间的节点删除后再插入
5. 删除链表的倒数第n的节点
   - 使用双指针，一个前移n的单位后另一个再前移
   - 链表相交（找到两个链表之间的长度差值），本质上都是通过使用指针使得实现固定距离的操作。
6. 判断链表中是否有环以及进入环的节点
   - 使用快慢指针判断是否有环，是否循环（快指针为2，慢指针为1，两者肯定会相遇）
   - 推导出进入环的位置的长度与快慢指针相遇位置距离入口处的长度相差的是环的长度，进而得出入口位置

### 三、哈希表

1. 





kmp：j同时也表示到达i的子串的最长相等前后缀的长度



### 动态规划

> 主要就是确定动态数组的意义

- 五部曲：
  1. 确定动态数组的含义
  2. 确定递推公式
  3. dp数组如何初始化
  4. 确定遍历顺序
  5. 距离推导dp数组

